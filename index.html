<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Juego de la Nubecita - Versión Detallada</title>
  <style>
    /* Estilo básico para que el canvas ocupe toda la pantalla sin márgenes */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87CEEB; /* Color de fondo: cielo */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // -----------------------------------------------------
    // CONFIGURACIÓN DEL JUEGO
    // -----------------------------------------------------
    // Velocidades:
    // PROTAGONISTA_SPEED: velocidad base en píxeles por frame para la nubecita protagonista.
    // SPEED_RATIO: factor que hace que la protagonista se mueva un 30% más rápido que las nubes negras.
    const PROTAGONISTA_SPEED = 4; 
    const SPEED_RATIO = 1.3; // La protagonista va 30% más rápido que cada nube negra.
    const ENEMY_SPEED = PROTAGONISTA_SPEED / SPEED_RATIO; // Velocidad de los enemigos

    // Tamaños (radio) de la nubecita protagonista y de las nubes enemigas
    const PROTAGONISTA_RADIUS = 20;
    const ENEMY_RADIUS = 20;

    // Intervalo de tiempo (en milisegundos) para que aparezca una nueva nube negra
    const ENEMY_SPAWN_INTERVAL = 5000;

    // -----------------------------------------------------
    // CONFIGURACIÓN DEL CANVAS
    // -----------------------------------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Función para ajustar el canvas al tamaño completo de la ventana
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // -----------------------------------------------------
    // VARIABLES GLOBALES DEL JUEGO
    // -----------------------------------------------------
    // Score y control de tiempo para movimientos suaves
    let score = 0;
    let lastTime = performance.now(); // Marca el tiempo del último frame

    // Objeto que representa a la nubecita protagonista
    let protagonista = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      vx: PROTAGONISTA_SPEED, // Dirección inicial: se mueve a la derecha
      vy: 0
    };

    // Array que contendrá las nubes negras enemigas
    let enemies = [];

    // Variable para guardar el intervalo que crea nuevos enemigos
    let enemySpawner = null;

    // -----------------------------------------------------
    // FUNCIONES DEL JUEGO
    // -----------------------------------------------------

    // Función que reinicia el juego en caso de colisión
    function resetGame() {
      alert("¡Has perdido! Reiniciando juego.");
      // Reinicia la posición y dirección de la protagonista al centro
      protagonista.x = canvas.width / 2;
      protagonista.y = canvas.height / 2;
      protagonista.vx = PROTAGONISTA_SPEED;
      protagonista.vy = 0;
      // Reinicia la puntuación
      score = 0;
      // Vacía el array de enemigos
      enemies = [];
      // Reinicia el spawner de enemigos
      if (enemySpawner) clearInterval(enemySpawner);
      // Inicia con un enemigo nuevo y establece el spawner para cada 5 segundos
      spawnEnemy();
      enemySpawner = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);
      // Reinicia el tiempo para los cálculos de deltaTime
      lastTime = performance.now();
    }

    // Función para generar una nueva nube negra en una posición y dirección aleatoria
    function spawnEnemy() {
      // Posición aleatoria dentro del canvas
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      // Ángulo aleatorio para definir la dirección lineal del movimiento
      const angle = Math.random() * Math.PI * 2;
      const vx = Math.cos(angle) * ENEMY_SPEED;
      const vy = Math.sin(angle) * ENEMY_SPEED;
      enemies.push({ x, y, vx, vy });
    }

    // Función para actualizar la posición de un objeto y aplicar el efecto wrap-around (salida/reentrada por los bordes)
    // deltaTime permite ajustar la actualización según el tiempo transcurrido (movimiento suave)
    function updatePosition(obj, radius, deltaTime) {
      obj.x += obj.vx * deltaTime;
      obj.y += obj.vy * deltaTime;
      // Wrap-around horizontal
      if (obj.x < -radius) obj.x = canvas.width + radius;
      if (obj.x > canvas.width + radius) obj.x = -radius;
      // Wrap-around vertical
      if (obj.y < -radius) obj.y = canvas.height + radius;
      if (obj.y > canvas.height + radius) obj.y = -radius;
    }

    // Función para detectar la colisión entre dos círculos
    function isColliding(a, b, rA, rB) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const distance = Math.hypot(dx, dy);
      return distance < (rA + rB);
    }

    // Función para dibujar una nube en el canvas.
    // Se utiliza para la protagonista (color blanco) y para los enemigos (color negro).
    // Se simula una forma esponjosa dibujando varios arcos.
    function drawCloud(x, y, radius, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      // Arco de la parte superior izquierda
      ctx.arc(x, y, radius, Math.PI * 0.5, Math.PI * 1.5);
      // Arco de la parte superior derecha
      ctx.arc(x + radius, y - radius, radius, Math.PI, Math.PI * 2);
      // Arco de la parte inferior derecha
      ctx.arc(x + radius * 2, y, radius, Math.PI * 1.5, Math.PI * 0.5);
      // Arco de la parte inferior izquierda
      ctx.arc(x + radius, y + radius, radius, 0, Math.PI);
      ctx.closePath();
      ctx.fill();
    }

    // Función para dibujar la puntuación en la esquina superior izquierda
    function drawScore() {
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      ctx.fillText("Puntuación: " + Math.floor(score), 10, 30);
    }

    // Función para mostrar instrucciones en pantalla (opcional)
    function drawInstructions() {
      ctx.fillStyle = "black";
      ctx.font = "18px Arial";
      const instructions = [
        "Instrucciones:",
        "Usa las flechas del teclado o realiza un swipe en tu dispositivo móvil",
        "para mover la nubecita blanca.",
        "Evita chocar con las nubes negras.",
        "Cada 5 segundos aparece una nueva nube negra.",
        "¡Sobrevive el mayor tiempo posible!"
      ];
      instructions.forEach((line, index) => {
        ctx.fillText(line, 10, 60 + index * 25);
      });
    }

    // -----------------------------------------------------
    // MANEJO DE CONTROLES (TECLADO Y TOUCH)
    // -----------------------------------------------------
    // Controles para teclado: cambia la dirección de la protagonista según la flecha presionada
    window.addEventListener('keydown', function(e) {
      switch(e.key) {
        case 'ArrowUp':
          protagonista.vx = 0;
          protagonista.vy = -PROTAGONISTA_SPEED;
          break;
        case 'ArrowDown':
          protagonista.vx = 0;
          protagonista.vy = PROTAGONISTA_SPEED;
          break;
        case 'ArrowLeft':
          protagonista.vx = -PROTAGONISTA_SPEED;
          protagonista.vy = 0;
          break;
        case 'ArrowRight':
          protagonista.vx = PROTAGONISTA_SPEED;
          protagonista.vy = 0;
          break;
      }
    });

    // Variables para detectar swipes en dispositivos móviles
    let touchStartX = null;
    let touchStartY = null;
    const swipeThreshold = 30; // Umbral en píxeles para considerar que se realizó un swipe

    // Detectar el inicio del toque
    canvas.addEventListener('touchstart', function(e) {
      const touch = e.changedTouches[0];
      touchStartX = touch.screenX;
      touchStartY = touch.screenY;
    }, false);

    // Detectar el final del toque y calcular la dirección del swipe
    canvas.addEventListener('touchend', function(e) {
      if (touchStartX === null || touchStartY === null) return;
      const touch = e.changedTouches[0];
      const deltaX = touch.screenX - touchStartX;
      const deltaY = touch.screenY - touchStartY;
      // Resetear las variables de inicio
      touchStartX = null;
      touchStartY = null;
      // Si el movimiento es muy corto, no se considera swipe
      if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) return;
      // Determinar la dirección predominante del movimiento
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Movimiento horizontal
        if (deltaX > 0) {
          // Swipe a la derecha
          protagonista.vx = PROTAGONISTA_SPEED;
          protagonista.vy = 0;
        } else {
          // Swipe a la izquierda
          protagonista.vx = -PROTAGONISTA_SPEED;
          protagonista.vy = 0;
        }
      } else {
        // Movimiento vertical
        if (deltaY > 0) {
          // Swipe hacia abajo
          protagonista.vx = 0;
          protagonista.vy = PROTAGONISTA_SPEED;
        } else {
          // Swipe hacia arriba
          protagonista.vx = 0;
          protagonista.vy = -PROTAGONISTA_SPEED;
        }
      }
    }, false);

    // -----------------------------------------------------
    // BUCLE PRINCIPAL DEL JUEGO
    // -----------------------------------------------------
    function gameLoop(currentTime) {
      // Calcular deltaTime (tiempo transcurrido en relación a 60fps, aproximadamente 16.67 ms por frame)
      let deltaTime = (currentTime - lastTime) / 16.67;
      lastTime = currentTime;

      // Incrementar el score en función del tiempo transcurrido
      score += deltaTime * 0.1; // Factor de incremento (puedes ajustarlo según prefieras)

      // Limpiar el canvas para el nuevo frame
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Dibujar las instrucciones (opcional: si prefieres no mostrarlas constantemente, comenta esta línea)
      drawInstructions();

      // Actualizar y dibujar la nubecita protagonista
      updatePosition(protagonista, PROTAGONISTA_RADIUS, deltaTime);
      // Se ajusta la posición de dibujo para centrar la forma de la nube
      drawCloud(protagonista.x - PROTAGONISTA_RADIUS, protagonista.y - PROTAGONISTA_RADIUS, PROTAGONISTA_RADIUS, "white");

      // Actualizar y dibujar cada una de las nubes negras enemigas
      for (let enemy of enemies) {
        updatePosition(enemy, ENEMY_RADIUS, deltaTime);
        drawCloud(enemy.x - ENEMY_RADIUS, enemy.y - ENEMY_RADIUS, ENEMY_RADIUS, "black");
        // Detectar colisión entre la protagonista y el enemigo
        if (isColliding(protagonista, enemy, PROTAGONISTA_RADIUS, ENEMY_RADIUS)) {
          resetGame();
          return; // Terminar el frame actual si se detecta colisión
        }
      }

      // Dibujar la puntuación en pantalla
      drawScore();

      // Solicitar el siguiente frame de animación
      requestAnimationFrame(gameLoop);
    }

    // -----------------------------------------------------
    // INICIAR EL JUEGO
    // -----------------------------------------------------
    // Inicia el juego: crea el primer enemigo, configura el spawner y arranca el bucle de animación
    spawnEnemy();
    enemySpawner = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
