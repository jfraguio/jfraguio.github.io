<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Juego de la Nubecita - Pájaros, Arcoíris y Modo Rainbow</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87CEEB; /* Fondo tipo cielo */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // -----------------------------------------------------
    // CONFIGURACIÓN DEL JUEGO
    // -----------------------------------------------------
    // Velocidades:
    const PROTAGONISTA_SPEED = 4;            // Velocidad base de la nube protagonista.
    const SPEED_RATIO = 1.3;                 // La protagonista se mueve 30% más rápido.
    const ENEMY_SPEED = PROTAGONISTA_SPEED / SPEED_RATIO; // Velocidad de las nubes negras.

    // Tamaños (radio de la nube)
    const PROTAGONISTA_RADIUS = 20;
    const ENEMY_RADIUS = 20;

    // Intervalos de aparición:
    const ENEMY_SPAWN_INTERVAL = 10000; // Nube negra cada 10 segundos.
    const BIRD_SPAWN_INTERVAL = 5000;   // Pájaro cada 5 segundos.

    // Duraciones (en milisegundos)
    const RAINBOW_DURATION = 3000; // El arcoíris es visible 3 segundos.
    const RAINBOW_MODE_DURATION = 5000; // Modo arcoíris activo 5 segundos.

    // -----------------------------------------------------
    // CONFIGURACIÓN DEL CANVAS
    // -----------------------------------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // -----------------------------------------------------
    // VARIABLES GLOBALES DEL JUEGO
    // -----------------------------------------------------
    let score = 0;
    let lastTime = performance.now();

    // Protagonista: nube con propiedades adicionales.
    let protagonista = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      vx: PROTAGONISTA_SPEED, // Dirección inicial: a la derecha.
      vy: 0,
      rainbow: false,         // Modo arcoíris activo.
      rainbowUntil: 0         // Tiempo hasta el que permanece en modo arcoíris.
    };

    // Arrays para enemigos (nubes negras) y pájaros.
    let enemies = [];
    let birds = [];

    // Arcoíris: se crea al tocar un pájaro.
    let rainbowEntity = null;

    // Spawners (intervalos de creación)
    let enemySpawner = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);
    let birdSpawner = setInterval(spawnBird, BIRD_SPAWN_INTERVAL);

    // -----------------------------------------------------
    // FUNCIONES DE GESTIÓN DEL JUEGO
    // -----------------------------------------------------
    function resetGame() {
      alert("¡Has perdido! Reiniciando juego.");
      protagonista.x = canvas.width / 2;
      protagonista.y = canvas.height / 2;
      protagonista.vx = PROTAGONISTA_SPEED;
      protagonista.vy = 0;
      protagonista.rainbow = false;
      protagonista.rainbowUntil = 0;
      score = 0;
      enemies = [];
      birds = [];
      rainbowEntity = null;
      lastTime = performance.now();
      // Reiniciamos con un primer enemigo.
      spawnEnemy();
    }

    // Genera una nube negra (enemigo) en posición y dirección aleatoria.
    function spawnEnemy() {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const angle = Math.random() * Math.PI * 2;
      const vx = Math.cos(angle) * ENEMY_SPEED;
      const vy = Math.sin(angle) * ENEMY_SPEED;
      enemies.push({ x, y, vx, vy });
    }

    // Genera un pájaro que entra desde la izquierda y se desplaza hacia la derecha.
    function spawnBird() {
      const x = -30; // Comienza fuera de la pantalla.
      const y = Math.random() * canvas.height;
      const BIRD_SPEED = 6;
      birds.push({ x, y, vx: BIRD_SPEED, vy: 0 });
    }

    // Actualiza la posición de un objeto aplicando efecto wrap-around.
    function updatePosition(obj, radius, deltaTime) {
      obj.x += obj.vx * deltaTime;
      obj.y += obj.vy * deltaTime;
      if (obj.x < -radius) obj.x = canvas.width + radius;
      if (obj.x > canvas.width + radius) obj.x = -radius;
      if (obj.y < -radius) obj.y = canvas.height + radius;
      if (obj.y > canvas.height + radius) obj.y = -radius;
    }

    // Función de colisión entre dos círculos.
    function isColliding(a, b, rA, rB) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const distance = Math.hypot(dx, dy);
      return distance < (rA + rB);
    }

    // Función de colisión entre un círculo y un rectángulo.
    function isCircleRectColliding(circle, radius, rect) {
      let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
      let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
      let dx = circle.x - closestX;
      let dy = circle.y - closestY;
      return (dx * dx + dy * dy) < (radius * radius);
    }

    // -----------------------------------------------------
    // FUNCIÓN DE DIBUJO
    // -----------------------------------------------------
    // Dibuja la nube (protagonista) con ojos y boca. Si está en modo rainbow, se pinta con franjas de colores y sonríe.
    function drawProtagonist(currentTime) {
      ctx.save();
      let x = protagonista.x, y = protagonista.y, radius = PROTAGONISTA_RADIUS;
      // Dibuja la forma de la nube.
      ctx.beginPath();
      ctx.arc(x - radius, y - radius, radius, Math.PI * 0.5, Math.PI * 1.5);
      ctx.arc(x, y - 2 * radius, radius, Math.PI, Math.PI * 2);
      ctx.arc(x + radius, y - radius, radius, Math.PI * 1.5, Math.PI * 0.5);
      ctx.arc(x, y, radius, 0, Math.PI);
      ctx.closePath();
      if (protagonista.rainbow) {
         // Degradado multicolor para el modo rainbow.
         let grad = ctx.createLinearGradient(x - radius, y - 2 * radius, x + radius, y);
         grad.addColorStop(0, "red");
         grad.addColorStop(0.16, "orange");
         grad.addColorStop(0.33, "yellow");
         grad.addColorStop(0.5, "green");
         grad.addColorStop(0.66, "blue");
         grad.addColorStop(0.83, "indigo");
         grad.addColorStop(1, "violet");
         ctx.fillStyle = grad;
      } else {
         ctx.fillStyle = "white";
      }
      ctx.fill();
      
      // Dibujar ojos.
      let eyeRadius = radius * 0.15;
      let eyeOffsetX = radius * 0.5;
      let eyeOffsetY = radius * 0.3;
      ctx.beginPath();
      ctx.arc(x - eyeOffsetX, y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
      ctx.fillStyle = "black";
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + eyeOffsetX, y - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
      ctx.fill();

      // Dibujar boca: si está en modo rainbow o si se activó la sonrisa, se dibuja una sonrisa.
      ctx.beginPath();
      if (protagonista.rainbow) {
         // Sonrisa amplia.
         ctx.arc(x, y + radius * 0.2, radius * 0.6, 0, Math.PI, false);
      } else {
         // Boca neutra (línea recta).
         ctx.moveTo(x - radius * 0.6, y + radius * 0.4);
         ctx.lineTo(x + radius * 0.6, y + radius * 0.4);
      }
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    // Dibuja una nube negra (enemigo) usando la misma función de nube pero en color negro.
    function drawCloud(x, y, radius, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, radius, Math.PI * 0.5, Math.PI * 1.5);
      ctx.arc(x + radius, y - radius, radius, Math.PI, Math.PI * 2);
      ctx.arc(x + radius * 2, y, radius, Math.PI * 1.5, Math.PI * 0.5);
      ctx.arc(x + radius, y + radius, radius, 0, Math.PI);
      ctx.closePath();
      ctx.fill();
    }

    // Dibuja un pájaro (paloma alargada) con aleteo.
    function drawBird(bird, currentTime) {
      ctx.save();
      ctx.translate(bird.x, bird.y);
      // Cuerpo: elíptico
      ctx.fillStyle = "gray";
      ctx.beginPath();
      ctx.ellipse(0, 0, 15, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      // Alas: se animan con oscilación para simular aleteo.
      let wingOffset = Math.sin(currentTime / 200) * 5;
      ctx.fillStyle = "darkgray";
      // Ala izquierda
      ctx.beginPath();
      ctx.ellipse(-5, -7 + wingOffset, 8, 4, -0.5, 0, Math.PI * 2);
      ctx.fill();
      // Ala derecha
      ctx.beginPath();
      ctx.ellipse(-5, 7 + wingOffset, 8, 4, 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Dibuja el arcoíris como una franja horizontal que atraviesa la pantalla.
    function drawRainbow(rainbow) {
      // Se dibuja como un rectángulo con 7 bandas de colores.
      let colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"];
      let bandHeight = rainbow.height / colors.length;
      for (let i = 0; i < colors.length; i++) {
         ctx.fillStyle = colors[i];
         ctx.fillRect(rainbow.x, rainbow.y, rainbow.width, bandHeight);
         rainbow.y += bandHeight;
      }
      // Restauramos la posición vertical original para futuras iteraciones.
      rainbow.y -= rainbow.height;
    }

    // Dibuja la puntuación.
    function drawScore() {
      ctx.fillStyle = "black";
      ctx.font = "20px Arial";
      ctx.fillText("Puntuación: " + Math.floor(score), 10, 30);
    }

    // -----------------------------------------------------
    // MANEJO DE CONTROLES (TECLADO Y TOUCH)
    // -----------------------------------------------------
    window.addEventListener('keydown', function(e) {
      switch(e.key) {
        case 'ArrowUp':
          protagonista.vx = 0;
          protagonista.vy = -PROTAGONISTA_SPEED;
          break;
        case 'ArrowDown':
          protagonista.vx = 0;
          protagonista.vy = PROTAGONISTA_SPEED;
          break;
        case 'ArrowLeft':
          protagonista.vx = -PROTAGONISTA_SPEED;
          protagonista.vy = 0;
          break;
        case 'ArrowRight':
          protagonista.vx = PROTAGONISTA_SPEED;
          protagonista.vy = 0;
          break;
      }
    });
    let touchStartX = null, touchStartY = null;
    const swipeThreshold = 30;
    canvas.addEventListener('touchstart', function(e) {
      const touch = e.changedTouches[0];
      touchStartX = touch.screenX;
      touchStartY = touch.screenY;
    }, false);
    canvas.addEventListener('touchend', function(e) {
      if (touchStartX === null || touchStartY === null) return;
      const touch = e.changedTouches[0];
      const deltaX = touch.screenX - touchStartX;
      const deltaY = touch.screenY - touchStartY;
      touchStartX = null;
      touchStartY = null;
      if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) return;
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0) {
          protagonista.vx = PROTAGONISTA_SPEED;
          protagonista.vy = 0;
        } else {
          protagonista.vx = -PROTAGONISTA_SPEED;
          protagonista.vy = 0;
        }
      } else {
        if (deltaY > 0) {
          protagonista.vx = 0;
          protagonista.vy = PROTAGONISTA_SPEED;
        } else {
          protagonista.vx = 0;
          protagonista.vy = -PROTAGONISTA_SPEED;
        }
      }
    }, false);

    // -----------------------------------------------------
    // BUCLE PRINCIPAL DEL JUEGO
    // -----------------------------------------------------
    function gameLoop(currentTime) {
      let deltaTime = (currentTime - lastTime) / 16.67;
      lastTime = currentTime;
      score += deltaTime * 0.1;

      // Limpiar el canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Actualización de la posición del protagonista.
      updatePosition(protagonista, PROTAGONISTA_RADIUS, deltaTime);
      // Si el modo rainbow está activo y se ha superado el tiempo, se desactiva.
      if (protagonista.rainbow && currentTime > protagonista.rainbowUntil) {
         protagonista.rainbow = false;
      }
      
      // Dibujar la protagonista.
      drawProtagonist(currentTime);

      // Procesar enemigos (nubes negras): se recorre hacia atrás para poder eliminarlos.
      for (let i = enemies.length - 1; i >= 0; i--) {
        let enemy = enemies[i];
        updatePosition(enemy, ENEMY_RADIUS, deltaTime);
        drawCloud(enemy.x - ENEMY_RADIUS, enemy.y - ENEMY_RADIUS, ENEMY_RADIUS, "black");
        if (isColliding(protagonista, enemy, PROTAGONISTA_RADIUS, ENEMY_RADIUS)) {
          if (protagonista.rainbow) {
            // En modo rainbow, la colisión hace desaparecer la nube negra.
            enemies.splice(i, 1);
          } else {
            resetGame();
            return;
          }
        }
      }

      // Procesar pájaros.
      for (let i = birds.length - 1; i >= 0; i--) {
        let bird = birds[i];
        bird.x += bird.vx * deltaTime;
        bird.y += bird.vy * deltaTime;
        // El pájaro desaparece al salir de la pantalla.
        if (bird.x > canvas.width + 30) {
          birds.splice(i, 1);
          continue;
        }
        drawBird(bird, currentTime);
        // Si la nube toca un pájaro, se elimina el pájaro y se genera el arcoíris.
        if (isColliding(protagonista, bird, PROTAGONISTA_RADIUS, 15)) {
          birds.splice(i, 1);
          // Se crea el arcoíris (se mostrará durante 3 segundos).
          rainbowEntity = {
            spawnTime: currentTime,
            duration: RAINBOW_DURATION,
            x: 0,
            y: canvas.height / 2 - 50, // Se centra verticalmente; altura 100.
            width: canvas.width,
            height: 100
          };
        }
      }

      // Procesar el arcoíris.
      if (rainbowEntity) {
        drawRainbow(rainbowEntity);
        // Se comprueba la colisión entre la nube y el arcoíris (usando colisión círculo-rectángulo).
        if (isCircleRectColliding(protagonista, PROTAGONISTA_RADIUS, rainbowEntity)) {
          protagonista.rainbow = true;
          protagonista.rainbowUntil = currentTime + RAINBOW_MODE_DURATION;
          // Al activarse el modo rainbow, se elimina el arcoíris.
          rainbowEntity = null;
        } else if (currentTime - rainbowEntity.spawnTime > rainbowEntity.duration) {
          // Si han pasado 3 segundos sin que la nube toque el arcoíris, se elimina.
          rainbowEntity = null;
        }
      }

      // Dibujar la puntuación.
      drawScore();

      requestAnimationFrame(gameLoop);
    }

    // Iniciar el juego: primer enemigo y comienzo del bucle.
    spawnEnemy();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
